# -*- coding: utf-8 -*-
"""notebook algoritmos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_zbHMhm2GORSQMYBNgXajMfOJTXGHDIU

Diferença de variáveis int e float
"""

a = 5
b = 4.0
c = a+b
print(c)
print("c")

"""Tabela verdade e

"""

x0 = 0
y0 = 0

x1 = 0
y1 = 1

x2 = 1
y2 = 0

x3 = 1
y3 = 1

print (x0 & y0)
print (x1 & y1)
print (x2 & y2)
print (x3 & y3)

n1=input('digite um número: ')
print(type(n1))

n1=int(input('digite um número: '))
print(type(n1))

n1=float(input('digite um número: '))
print(type(n1))

n1=int(input('digite um número: '))
n2=int(input('digite um número: '))
soma=n1+n2
print('Resultado da soma: ',soma)

n1=float(input('digite um número: '))
n2=float(input('digite um número: '))
soma=n1+n2
print('Resultado da soma: ',soma)

n1=float(input('digite um número: '))
n2=float(input('digite um número: '))
soma=n1+n2
print('A soma é {}'.format(soma))

#A soma entre <<n1>> e <<n2>> é <<soma>> - forma antiga
n1=float(input('digite um número: '))
n2=float(input('digite um número: '))
soma=n1+n2
print('A soma entre', n1, 'e', n2, 'é:',soma)

#A soma entre <<n1>> e <<n2>> é <<soma>> - formato novo 1
n1=float(input('digite um número: '))
n2=float(input('digite um número: '))
soma=n1+n2
print('A soma entre {} e {} é: {}'.format(n1, n2, soma))

#A soma entre <<n1>> e <<n2>> é <<soma>> - formato novo 2
n1=float(input('digite um número: '))
n2=float(input('digite um número: '))
soma=n1+n2
print(f'A soma entre {n1} e {n2} é: {soma}')

print(5 + 3 * 2)
print(3 * 5 + 4 ** 2)
print(3 * (5 + 4) ** 2)

"""Receba dois números inteiros, faça e exiba o resultado das operações matemáticas básicas (+,-,*,/)"""

n1=int(input('digite um número: '))
n2=int(input('digite um número: '))
soma=n1+n2
sub=n1-n2
mult=n1*n2
div=n1/n2
print(f'A soma entre {n1} e {n2} é: {soma}')
print(f'A subtração entre {n1} e {n2} é: {sub}')
print(f'A multiplicação entre {n1} e {n2} é: {mult}')
print(f'A divisão entre {n1} e {n2} é: {div}')

"""Receba dois números inteiros, faça e exiba: a potência entre os dois números, o resto da divisão entre os dois números e a divisão inteira entre os dois números.

"""

n1=int(input('digite um número: '))
n2=int(input('digite um número: '))
pot1=n1**n2 #pot(n1,n2)
pot2=n2**n1 #pot(n2,n1)
rest1=n1%n2
rest2=n2%n1
div1=n1//n2
div2=n2//n1
print(f'A potencia entre {n1} e {n2} é: {pot1}')
print(f'A potencia entre {n2} e {n1} é: {pot2}')
print(f'O resto entre {n1} e {n2} é: {rest1}')
print(f'O resto entre {n2} e {n1} é: {rest2}')
print(f'A divisão inteiria entre {n1} e {n2} é: {div1}')
print(f'A divisão inteiria entre {n2} e {n1} é: {div2}')

nome=input('Digite seu nome: ')
print(f"Bem vindo {nome}!")
print(f"Bem vindo {nome:20}!")
print(f"Bem vindo {nome :>20}!")
print(f"Bem vindo {nome:<20}!")
print(f"Bem vindo {nome:^20}!")
print(f"Bem vindo {nome:=^20}!")
print(f"Bem vindo {nome:~^20}!")

import math
print (math.pi)
print (math.e)

#Ler um número real e usar sobre ele os métodos: ceil, floor e trunc;
import math
n1=float(input('digite um número: '))
print(n1)
print(math.ceil(n1))
print(math.floor(n1))
print(math.trunc(n1))

# Ler um número real e calcular sua raiz quadrada usando sqrt;
import math
n1=float(input('digite um número: '))
print(n1)
print(math.sqrt(n1))

# Ler um número inteiro e calcular seu fatorial;
#import math
n1=int(input('digite um número: '))
print(n1)
print(math.factorial(n1))

#Ler o cateto oposto e o cateto adjacente de um triângulo retângulo, calcular e mostrar sua hipotenusa (use o método tradicional);
co=int(input('digite cateto oposto: '))
ca=int(input('digite cateto adjacente: '))
hip=((ca)**2+(co)**2)**(1/2)
print(f'hipotenusa: {hip}')

#Ler o cateto oposto e o cateto adjacente de um triângulo retângulo, calcular e mostrar sua hipotenusa (use o math);
import math
co=int(input('digite cateto oposto: '))
ca=int(input('digite cateto adjacente: '))
hip=math.sqrt(pow(ca,2)+pow(co,2))
print(f'hipotenusa: {hip}')

#testes com o random
import random
lista = ['André','Luis','Paulo','Thomas']
lista1 = ['0','1','2','3']
print(random.choice(lista))
random.shuffle(lista)
print(lista)
random.shuffle(lista1)
print(lista1)

nome = 'FATEC'
print(len(nome))
print(nome.count('A'))
print(nome.find('AT'))
print(nome.find('EC'))
print(nome.find('CD'))

nome = 'FATEC'
trocado = nome.replace('AT', 'XX')
print(trocado)
nome = 'FateC'
maiuscula = nome.upper()
print(maiuscula)
minuscula = nome.lower()
print(minuscula)
print(nome.capitalize())
print(nome.title())

nome = '   FATEC   '
print(nome)
print(nome.strip(),'!')
print(nome.lstrip(),'!')
print(nome.rstrip(),'!')

nome = 'André \nLuis \nPaulo \nThomas'
lista = nome.split()
print(nome)
print(lista)

import requests
x = requests.get('https://fatecourinhos.edu.br/')
print(x.status_code)
print(x.headers)
print(x.content)

"""=========================================================================================================================================================================================================================================================================================================================================================







**Aula do dia 19/04 - Desvios Condicionais:**

**Condicionais Simples:**
"""

# Exemplo verificar maioridade:
idade = int(float(input('Digite sua idade: ')))
if idade >= 18:
  print('Vc é maior de idade')
else:
  print('Vc é menor de idade')

# Exemplo verificar maioridade (outra forma):
idade = int(input('Digite sua idade: '))
print('Vc é maior de idade' if idade>=18 else 'Vc é menor de idade')

# Ler duas notas reais, calcular a média e verificar se a pessoa está APROVADA (média >= 6) ou REPROVADA, caso contrário;
n1 = float(input('Digite o valor da nota 1: '))
n2 = float(input('Digite o valor da nota 2: '))
media = (n1+n2)/2
print(media)
if media >= 6:
	print('Aprovado')
else:
	print('Reprovado')

# Ler um número inteiro e verificar se é PAR ou ÍMPAR;
n = int(input('Digite um número inteiro: '))
resto = n % 2
if resto == 0:
	print('O número é par')
else:
	print('O número é ímpar')

# Ler um número e verificar se é POSITIVO ou NEGATIVO. Suponha que nunca irá digitar zero (0);
n = int(input('Digte um número inteiro: '))
if n > 0:
	print('Número positivo')
else:
	print('Número negativo')

# Ler dois números inteiros e verificar qual é o maior e qual é o menor. Suponha sempre números diferentes;
n1 = float(input('Digite o primeiro número: '))
n2 = float(input('Digite o segundo número: '))
if n1 > n2:
	print('O número {} é maior que {}'.format(n1,n2))
	print('a')
else:
	print('O número {} é maior que {}'.format(n2,n1))
	print('b')

"""**Condicionais aninhados ou complexos (vários testes):**"""

# Leia um número e verifique se é POSITIVO ou NEGATIVO ou NEUTRO;
n = int(input('Digite um número inteiro: '))
if n > 0:
	print('Positivo')
elif n < 0:
	print('Negativo')
else:
	print('Neutro')

# Leia um sexo (M ou F) e faça as seguintes saídas: M – Masculino, F – Feminino. Se for diferente disto imprimir: CARACTER INVÁLIDO;
sexo = str(input('Digite o seu sexo (M/F): ')).strip().upper()
if sexo == 'M':
	print('Masculino')
elif sexo == 'F':
	print('Feminino')
else:
	print('Caracter Inválido')

# Leia um número para o usuário tentar adivinhar o número da sorte. Deve imprimir: CHUTE MUITO ALTO, CHUTE MUITO BAIXO ou ACERTOU;
num = int(input('Digite um número inteiro (entre 1 e 10)): '))
adivinha = 5;
if num > adivinha:
	print('CHUTE MUITO ALTO')
elif num < adivinha:
	print('CHUTE MUITO BAIXO')
else:
	print('ACERTOU Miseravi!! ;)')

x = int(input('Digite um número inteiro: '))
if x < 1:
  print('a')
elif x==1:
  print('1')
elif x > 1 and x < 3:
  print('b')
elif x==3:
  print('3')
elif x > 3 and x < 5:
  print('c')
elif x==5:
  print('5')
elif x > 5 and x < 7:
  print('d')
elif x==7:
  print('7')
else:
  print('e')

for cont in range(1, 10):
	print('Olá Mundo!')

for cont in range(1, 11):
	print(cont,end='\t')

for cont in range(10, 0, -1):
	print(cont*0.5)

for cont in range(0, 11, 2):
  print(cont)
print('----')
for cont in range(0, 6):
  print(cont*2)

import time
num = int(input('Digite o valor do limite final: '))
tempo = time.time()
for cont in range(1, num+1):
  print(cont)
tempo1 = time.time()
print(tempo1-tempo)

inicio = int(input('Digite o valor do limite inicial: '))
fim = int(input('Digite o valor do limite final: '))
inc = int(input('Digite o incremento: '))
for cont in range(inicio, fim+1, inc):
  print(cont)

# Utilizando for
# Desafio 1) Leia 5 números e mostre a soma entre eles;
# leitura de números; -ok
# somatorio destes números. -ok
# mostrar soma. -ok

numero = 0
soma = 0

for cont in range(1,6):
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  #print('soma parcial: ', soma)

print('Soma: ', soma)

# Utilizando while
# Desafio 1) Leia 5 números e mostre a soma entre eles;
# contador para o while; -ok
# leitura de números; -ok
# somatorio destes números; -ok
# mostrar soma. -ok

numero = 0
soma = 0
cont = 1

while cont < 6:
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  cont += 1
  #print('soma parcial: ', soma)

print('Soma: ', soma)

# Utilizando for - de trás pra frente
# Desafio 1) Leia 5 números e mostre a soma entre eles;
# leitura de números; -ok
# somatorio destes números. -ok
# mostrar soma. -ok

numero = 0
soma = 0

for cont in range(5,0,-1):
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  #print('soma parcial: ', soma)

print('Soma: ', soma)

# Utilizando while de tras pra frente
# Desafio 1) Leia 5 números e mostre a soma entre eles;
# contador para o while; -ok
# leitura de números; -ok
# somatorio destes números; -ok
# mostrar soma. -ok

numero = 0
soma = 0
cont = 5

while cont > 0:
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  cont -= 1
  #print('soma parcial: ', soma)

print('Soma: ', soma)

# Utilizando while de tras pra frente
# Desafio 1) Leia 5 números e mostre a soma entre eles - pare se a soma ultrapassar 100;
# contador para o while; -ok
# leitura de números; -ok
# somatorio destes números; -ok
# mostrar soma. -ok

numero = 0
soma = 0
cont = 1

while cont < 6:
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  print('soma parcial: ', soma)
  if soma > 100:
    break
  cont += 1

print('Soma: ', soma)

# Utilizando for
# Desafio 1) Leia 5 números e mostre a soma entre eles - pare se a soma ultrapassar 100;
# leitura de números; -ok
# somatorio destes números. -ok
# mostrar soma. -ok

numero = 0
soma = 0

for cont in range(1,6):
  print('Digite o ', cont,'º número: ', end='')
  numero = int(input())
  soma = soma + numero
  if soma > 99:
    break
  #print('soma parcial: ', soma)

print('Soma: ', soma)

# Utilizando while de tras pra frente
# Desafio 1) Leia números e mostre a soma entre eles - pare se o número 0 for digitado;
# condição para o while; -ok
# leitura de números; -ok
# somatorio destes números; -ok
# mostrar soma. -ok

numero = 1
soma = 0

while numero != 0 :
  print('Digite um número: ', end='')
  numero = int(input())
  soma = soma + numero
  #print('soma parcial: ', soma)
  #if soma > 100:
    #break

print('Soma: ', soma)

# Leia se os números digitados são 1, 2, 3 ou 4 e exiba as mensagens:
#1 - ótimo.
#2 - bom.
#3 - regular.
#4 - ruim.
# Se o número digitado não for um deles, exiba: opção errada (1-4)

otimo = 0
bom = 0
regular = 0
ruim = 0

while True:
  print('Classifique o atendimento (1-4), 5 sair: ', end='')
  numero = int(input())
  if numero == 1:
    print('1 - ótimo')
    otimo += 1
  elif numero == 2:
    print('2 - bom')
    bom += 1
  elif numero == 3:
    print('3 - regular')
    regular += 1
  elif numero == 4:
    print('4 - ruim')
    ruim += 1
  elif numero == 5:
    print('finalizado')
    break
  else:
    print('opção errada (1-5)')

print('Ótimo: ', otimo)
print('Bom: ', bom)
print('Regular: ', regular)
print('Ruim: ', ruim)

"""**Aula - Tuplas - 03/05/2023**"""

#Exemplos de Tuplas
tupla1 = (1, 30,  40,  50) #cria uma tupla com 4 elementos inteiros
tupla2 = ('maria', 'jose', 'ana') #cria uma tupla com 3 elementos strings
tupla3 = () #cria uma tupla vazia
tupla4 = (0,) #cria uma tupla com único elemento
tupla5 = tuple('teste') #cria uma tupla, onde cada letra se torna um elemento da lista
print(tupla1)
print(tupla2)
print(tupla3)
print(tupla4)
print(tupla5)

#Nomeando elementos de uma tupla
from collections import namedtuple
Estados = namedtuple('Estados', ['sigla', 'nome','regiao'])
estado_sp = Estados('SP', 'São Paulo','Sudeste')
estado_pr = Estados('PR','Curitiba','Sul')
estado_mg = Estados('MG','Belo Horizonte','Sudeste')
estado_mt = Estados('MT','Cuiabá','Centro Oeste')
print(estado_sp)
print(estado_pr)
print(estado_mg)
print(estado_mt)

#Percorrendo uma tupla
tupla = ('ana','maria',60,8.9,-10)
print(tupla[0])
print(tupla[1])
print(tupla[2])
print(tupla[3])
print(tupla[4])
print('Mostrando do inicio até elemento desejado: ',tupla[0:3])
print('Mostrando do inicio até elemento desejado: ',tupla[:3])
print('Mostrando o último elemento: ',tupla[-1])
print('Mostrando o último elemento: ',tupla[-2])
print('Mostrando o último elemento: ',tupla[-3])
print('Mostrando do último até o início',tupla[:-1]) #ultimo elemento não entra

# Procurando um elemento na tupla
# Operador in
# existe determinado elemento na tupla
capitais = ('São Paulo', 'Belo Horizonte', 'Fortaleza')
print(capitais)
print('Belo Horizonte está na tupla?', 'Belo Horizonte' in capitais)

# o elemento não existe na tupla
print('Rio de janeiro está na tupla? ', 'Rio de Janeiro' in capitais)

nome = tuple('Andre Giovanni Castaldin')
print('Existe a letra n neste nome?', 'n' in nome)
print('qtde de n: ', nome.count('n'))

#Contando elementos na tupla
#Método count()
nomes = ('Maria', 'Paulo', 'Maria', 'João', 'Sérgio')
print('qtde de Maria: ', nomes.count('Maria'))
print('qtde de Sérgio: ', nomes.count('Sérgio'))
print('qtde de Pedro: ', nomes.count('Pedro'))

#Exibindo índice de um elemento da tupla

nomes = ('Maria', 'João', 'Paulo', 'Pedro', 'Maria', 'Sérgio')
print(len(nomes))

#um parâmetro somente, retorna o primeiro índice encontrado
indice = nomes.index('Maria')
print(indice)

#passando valor, início da pesquisa, fim da pesquisa
#desta forma pesquisa se torna mais rápida de acordo com os
#valores inicias e finais
indice = nomes.index('Maria', 0, 5)
print(indice)

indice = nomes.index('Maria', 2, 5)
print(indice)

#percorrendo a tupla com for
filmes = ('Army of Dead','Vingadores','Homem-Aranha')

#modo antigo
for cont in range(0,len(filmes)):
	print(f'Eu vou assistir {filmes[cont]}')

#modo mais atual
for filme in filmes:
	print(f'Eu vou assistir {filme}')

multiplicador = (128,64,32,16,8,4,2,1)
bits=(1,1,1,0,1,1,1,1)

decimal=0

for cont in range(0,len(bits)):
  decimal = decimal + (multiplicador[cont]*bits[cont])

print(decimal)

# Gere números aleatórios em uma tupla e exibia no final, o maior e o menor número gerado;
import random
maior = 0
menor = 101

tupla = (random.randint(0, 100), random.randint(0, 100), random.randint(0, 100), random.randint(0, 100), random.randint(0, 100))
print(tupla)
for cont in range(0, len(tupla)):
  if tupla[cont] > maior:
    maior = tupla[cont]
  if tupla[cont] < menor:
    menor = tupla[cont]

print(maior)
print(menor)

"""# **Listas - 06/05/2023**"""

# Ler 5 números para uma lista e mostrar o maior e o menor e suas respectivas posições:

lista=[] # lista = list()

for i in range(0,5):
  lista.append(int(input(f'Digite o elemento para a posição {i} da lista: ')))

maior = max(lista)
menor = min(lista)
print('=' * 30)

print(f'Valores digitados: {lista}')

print(f'Maior valor digitado: {maior} e está nas posições: ', end=' ')
for i in range(0, 5):
  if lista[i] == maior:
    print(f'{i}', end='   ')

print(f'\nMenor valor digitado: {menor} e está nas posições: ', end=' ')
for i in range(0, 5):
  if lista[i] == menor:
    print(f'{i}', end='   ')

#Lendo números em uma lista e não aceitando duplicados

lista = []
resp = 'S'

while True:
  num = int(input('Digite um número para a lista: '))
  if num not in lista:
    lista.append(num)
    print('Número aceito!')
  else:
    print('Número duplicado. Não inserido na lista')
  resp = str(input('Quer continuar (S/N)?'))
  if resp in 'Nn':
    break

print('=' * 30)

print(f'Lista digitada: {lista}')

print(f'Lista digitada em ordem crescente: {sorted(lista)}')

# Lendo 5 números na lista e colocando-os na ordem correta (sem sort)

lista = []

for i in range(0, 5):
  num = int(input('Digite um número: '))
  if i == 0 or num > lista[-1]: # se num for maior que o último elemento:
    lista.append(num)
    print('Adicionado no fim da lista')
  else:
    pos = 0
    while pos <= len(lista): #varre a lista
      if num <= lista[pos]: #se for menor que o número na pos
        lista.insert(pos,num) #insere na pos correta
        print(f'Adicionado na posição {pos}')
        break
      pos += 1

print('=' * 30)
print(f'Valores ordenados na lista: {lista}')

# Tarefa 10 - Listas - Exercício 1 - Ler vários números em uma lista até que o usuário deseje.
# Exibir no final: a quantidade de números digitados, a lista em ordem decrescente e a quantidade de pares e ímpares.

lista = []
contp = 0
conti = 0
while True:
	num = int(input('Digite um número para a lista: '))
	lista.append(num)
	if num % 2 == 0:
		contp += 1
	else:
		conti += 1
	resp = str(input('Deseja continuar (S/N)?: '))
	if resp in 'nN':
		break

print(f'Lista em ordem descrecente: {sorted(lista, reverse=True)}')
print(f'Quantidade de números digitados: {len(lista)}')
print(f'Quantidade de pares: {contp}')
print(f'Quantidade de ímpares: {conti}')

#Tarefa 10 - Listas - Exercício 2 - Ler vários números para uma lista até que o
#usuário deseje. Depois criar mais duas listas: uma somente com os números pares e outra,
#somente com os números ímpares. Mostrar as 3 listas no final.

lista = []
listap = []
listai = []
while True:
	num = int(input('Digite um número para a lista: '))
	lista.append(num)
	if num % 2 == 0:
		listap.append(num)
	else:
		listai.append(num)

	resp = str(input('Deseja continuar (S/N)?: '))
	if resp in 'nN':
		break

print(f'Lista total: {lista}')
print(f'Lista pares: {listap}')
print(f'Lista impares: {listai}')

#Tarefa 10 - exercicio 3 - Crie um programa que leia uma expressão qualquer que use
#parênteses. Seu programa deve analisar a expressão passada e falar se ela é válida ou
#inválida.
#Ex: expressão lida: ((a + b) * c ) : expressão válida
#expressão lida: (a + b) * c ) : expressão inválida

lista=[]
expressao = str(input('Digite uma expressão: '))

for s in expressao:

	if s == '(':
		lista.append('(')
	elif s == ')':
		if len(lista)>0: # se a lista não está vazia.
			lista.pop()
		else:
			lista.append(')') # tem mais parenteses fechado
			break

if len(lista) == 0: #significa que todos os parenteses tem seu par
	print('Expressão válida')

else:
	print('Expressão inválida')

# Tarefa 9 - exercício 1 - Ler para uma tupla 5 nomes e 5 notas de alunos.
# Exibir os dados de forma tabular, e a média final da sala.

alunos = ('Ana', 10, 'José', 8.5, 'Maria', 7.5, 'André', 6, 'Isabela', 10)
soma = 0
print('=' * 25)
print(f'{"LISTAGEM DE ALUNOS":^25}')
print('=' * 25)

print(f'NOME{"NOTA":>20}')
#print(len(alunos))
for pos in range (0, len(alunos)):
	if pos % 2 == 0:
		print(f'{alunos[pos]:.<20}', end='')
	else:
		print(f'{alunos[pos]:>5.2f}')
		soma += alunos[pos]
media = soma / 5
print('=' * 25)
print(f'Media geral da sala: {media:.2f}')

#Códigos Aula Lista Composta - 13/05 - slide 14 - declarando a lista composta

LISTACURSOCD = [ ['JOÃO', '210001-2'], ['MARIA', '210003-3'] ]
print(LISTACURSOCD[0])
print(LISTACURSOCD[1])
print(LISTACURSOCD[0][0])
print(LISTACURSOCD[1][0])
print(LISTACURSOCD[0][1])
print(LISTACURSOCD[1][1])
print('Os nomes dos alunos são:')
for aluno in LISTACURSOCD:
  print(aluno[0])

#Códigos Aula Lista Composta - 13/05 - slide 15 - exibindo dados da lista

cursocd = [['João', '210001-1'], ['Maria', '210002-1'], ['Pedro', '210003-1']]

print('Os alunos com todos os dados: ')
for aluno in cursocd:
  print(aluno)

print('Somente o nome dos alunos: ')
for aluno in cursocd:
  print(aluno[0])

print('Somente o RA dos alunos: ')
for aluno in cursocd:
  print(aluno[1])

#Códigos Aula Lista Composta - 13/05 - slide 16 - lendo dados para uma lista composta
cursocd = list()
alunos = list()
for i in range(0, 3):
  alunos.append(str(input('Digite o nome do aluno: ')))
  alunos.append(str(input('Digite o RA do aluno: ')))
  cursocd.append(alunos[:])
  alunos.clear()
print(cursocd)

#Códigos Aula Lista Composta - 13/05 - slide 17
#Desafio: Faça um script que leia o nome e a idade de várias pessoas em uma lista composta. No final mostre quantas pessoas foram
#cadastradas, uma listagem (em tela) com os maiores de idade e uma listagem com os menores de idade (mostrando de forma tabular o nome e a idade)

geral = []
principal = []

while True:
  geral.append(str(input('Digite seu nome: ')).upper())
  geral.append(int(input('Digite sua idade: ')))
  principal.append(geral[:])
  geral.clear()

  resp = str(input('Quer continuar (s/n)?'))
  if resp in 'Nn':
    break

print('-'*50)
print(f'Foram cadastradas {len(principal)} pessoas')
print('-'*50)
print('Maiores de idade: ')
print('-'*50)
print(f'NOME{"IDADE":>40}')
print('-'*50)
for p in principal:
  if p[1] >= 18:
    print(f'{p[0]:.<40}{p[1]}')
print('-'*50)
print('Menores de idade: ')
print('-'*50)
print(f'NOME{"IDADE":>40}')
print('-'*50)
for p in principal:
  if p[1] < 18:
    print(f'{p[0]:.<40}{p[1]}')

#Códigos Aula Lista Composta - 13/05 - slide 17
#Desafio: Faça um script que leia 10 números inteiros para uma lista composta (por 3 listas internas) que mantenha separados os
#números positivos, negativos e os números neutros. No final mostre todas as sub-listas em ordem crescente.

nums = [[],[],[]]

for i in range(1,11):
  n=int(input(f'Digite o {i}° número: '))
  if n > 0:
    nums[0].append(n)
  elif n < 0:
    nums[1].append(n)
  else:
    nums[2].append(n)

print(f'Valores digitados: {nums}')
print(f'Valores positivos: {nums[0]}')
print(f'Valores negativos: {nums[1]}')
print(f'Valores neutros: {nums[2]}')

#Códigos Aula Lista Composta - 13/05 - slide 18
#Faça um script que leia uma matriz 2 X 2 de números
#inteiros. Mostre no final a matriz em formatação correta
#(forma de matriz). Exemplo de saída:

matriz = [[0, 0], [0, 0]]

for lin in range(0, 2):
  for col in range(0, 2):
    matriz[lin][col] = int(input(f'Digite o elemento [{lin}][{col}] da matriz: '))

print('')
print('Lista composta: ', matriz)
print('')

#for linha in matriz:
#  print(linha)

print('linha 0: ', matriz[0]) #linha 0
print('linha 1: ', matriz[1]) #linha 1

for coluna in range(0,2):
  print('Coluna: ', coluna)
  for linha in matriz:
      print(linha[coluna])

print('')
print('Matriz digitada')
for lin in range(0, 2):
  for col in range(0, 2):
    print(f'[{matriz[lin][col]}]', end = ' ')
  print('')

# Aula do dia 17/05 - Dicionários:

#exemplo aluno
#alunos = {'nome': 'André', 'curso': 'Ciências de Dados'}
#print(alunos['nome'])
#alunos['nome'] = 'Leonardo'
#print(alunos['curso'])
#print(alunos)
alunos['idade'] = 45
#print(alunos)
#alunos['idade'] = 50
#print(alunos)
#del alunos['curso']
#print(alunos)
#print(type(alunos))
#ano = 2023
#print(type(ano))

#print('='*40)
#print(alunos.values())
#print(alunos.keys())
#print(alunos.items())

#print('='*40)
#for key, value in alunos.items():
#        print(f'O {key} é {value}')



#print('='*40)
#exemplo carro
#carro = {
#    "marca":"Chevrolet",
#    "modelo":"Onix",
#    "ano":2021
#    }
#print(carro)

#Qual a marca do carro?
#print(carro["marca"])

#Qual o tamanho do dicionário?
#print(len(carro))



#print('='*40)
#vários tipos de dados no dicionário....
#carro = {
#    "marca":"Chevrolet", #string
#    "modelo":"Onix",     #string
#    "ano":2021,          #inteiro
#    "cores":["branco", "preto", "buraco de cerca"] #lista
#    }
#print(carro)
#print(len(carro))



#print('='*40)
#construtor
carro = dict(marca = "Chevrolet", modelo = "Onix", ano = 2021)
print(carro)
print(len(carro))

carroteste = dict() #ou carroteste={}
print(len(carroteste))
carroteste['combustível']='gasolina'
print(len(carroteste))
carroteste['placa']='gju3450'
print(len(carroteste))
print(carroteste)

#Desafio 1

boletim = dict(nome = "", p1 = 0.0, p2 = 0.0, media = 0.0, situacao = "")
boletim['nome'] = input(f'Digite o nome: ')
boletim['p1'] = float(input(f'Digite a nota P1: '))
boletim['p2'] = float(input(f'Digite a nota P2: '))
boletim['media'] = (boletim['p1'] + boletim['p2'])/2
if boletim['media'] < 6:
  boletim['situacao']='Reprovado'
else:
  boletim['situacao']='Aprovado'
print(boletim)

"""## **Aula 24/05 - Matplotlib**"""

"""
*****************
Quick start guide
*****************

This tutorial covers some basic usage patterns and best practices to
help you get started with Matplotlib.

.. redirect-from:: /tutorials/introductory/usage

"""

# sphinx_gallery_thumbnail_number = 3
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

##############################################################################
#
# A simple example
# ================
#
# Matplotlib graphs your data on `.Figure`\s (e.g., windows, Jupyter
# widgets, etc.), each of which can contain one or more `~.axes.Axes`, an
# area where points can be specified in terms of x-y coordinates (or theta-r
# in a polar plot, x-y-z in a 3D plot, etc.).  The simplest way of
# creating a Figure with an Axes is using `.pyplot.subplots`. We can then use
# `.Axes.plot` to draw some data on the Axes:

fig, ax = plt.subplots()  # Create a figure containing a single axes.
ax.set_title("Exemplo 1")
ax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the axes.

# %%
#
# Note that to get this Figure to display, you may have to call ``plt.show()``,
# depending on your backend.  For more details of Figures and backends, see
# :ref:`figure_explanation`.
#
# .. _figure_parts:
#
# Parts of a Figure
# =================
#
# Here are the components of a Matplotlib Figure.
#
# .. image:: ../../_static/anatomy.png
#
# :class:`~matplotlib.figure.Figure`
# ----------------------------------
#
# The **whole** figure.  The Figure keeps
# track of all the child :class:`~matplotlib.axes.Axes`, a group of
# 'special' Artists (titles, figure legends, colorbars, etc), and
# even nested subfigures.
#
# The easiest way to create a new Figure is with pyplot::
#
#    fig = plt.figure()  # an empty figure with no Axes
#    fig, ax = plt.subplots()  # a figure with a single Axes
#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes
#    # a figure with one axes on the left, and two on the right:
#    fig, axs = plt.subplot_mosaic([['left', 'right-top'],
#                                   ['left', 'right_bottom]])
#
# It is often convenient to create the Axes together with the Figure, but you
# can also manually add Axes later on.  Note that many
# :doc:`Matplotlib backends </users/explain/backends>` support zooming and
# panning on figure windows.
#
# For more on Figures, see :ref:`figure_explanation`.
#
# :class:`~matplotlib.axes.Axes`
# ------------------------------
#
# An Axes is an Artist attached to a Figure that contains a region for
# plotting data, and usually includes two (or three in the case of 3D)
# :class:`~matplotlib.axis.Axis` objects (be aware of the difference
# between **Axes** and **Axis**) that provide ticks and tick labels to
# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also
# has a title
# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via
# :meth:`~matplotlib.axes.Axes.set_xlabel`), and a y-label set via
# :meth:`~matplotlib.axes.Axes.set_ylabel`).
#
# The :class:`~.axes.Axes` class and its member functions are the primary
# entry point to working with the OOP interface, and have most of the
# plotting methods defined on them (e.g. ``ax.plot()``, shown above, uses
# the `~.Axes.plot` method)
#
# :class:`~matplotlib.axis.Axis`
# ------------------------------
#
# These objects set the scale and limits and generate ticks (the marks
# on the Axis) and ticklabels (strings labeling the ticks).  The location
# of the ticks is determined by a `~matplotlib.ticker.Locator` object and the
# ticklabel strings are formatted by a `~matplotlib.ticker.Formatter`.  The
# combination of the correct `.Locator` and `.Formatter` gives very fine
# control over the tick locations and labels.
#
# :class:`~matplotlib.artist.Artist`
# ----------------------------------
#
# Basically, everything visible on the Figure is an Artist (even
# `.Figure`, `Axes <.axes.Axes>`, and `~.axis.Axis` objects).  This includes
# `.Text` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`
# objects, etc. When the Figure is rendered, all of the
# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such
# an Artist cannot be shared by multiple Axes, or moved from one to another.
#
# .. _input_types:
#
# Types of inputs to plotting functions
# =====================================
#
# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as
# input, or objects that can be passed to `numpy.asarray`.
# Classes that are similar to arrays ('array-like') such as `pandas`
# data objects and `numpy.matrix` may not work as intended.  Common convention
# is to convert these to `numpy.array` objects prior to plotting.
# For example, to convert a `numpy.matrix` ::
#
#   b = np.matrix([[1, 2], [3, 4]])
#   b_asarray = np.asarray(b)
#
# Most methods will also parse an addressable object like a *dict*, a
# `numpy.recarray`, or a `pandas.DataFrame`.  Matplotlib allows you to
# provide the ``data`` keyword argument and generate plots passing the
# strings corresponding to the *x* and *y* variables.

np.random.seed(19680801)  # seed the random number generator.
data = {'a': np.arange(50),
        'c': np.random.randint(0, 50, 50),
        'd': np.random.randn(50)}
data['b'] = data['a'] + 10 * np.random.randn(50)
data['d'] = np.abs(data['d']) * 100

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.scatter('a', 'b', c='c', s='d', data=data)
ax.set_xlabel('entry a')
ax.set_ylabel('entry b')

##############################################################################
# .. _coding_styles:
#
# Coding styles
# =============
#
# The explicit and the implicit interfaces
# ----------------------------------------
#
# As noted above, there are essentially two ways to use Matplotlib:
#
# - Explicitly create Figures and Axes, and call methods on them (the
#   "object-oriented (OO) style").
# - Rely on pyplot to implicitly create and manage the Figures and Axes, and
#   use pyplot functions for plotting.
#
# See :ref:`api_interfaces` for an explanation of the tradeoffs between the
# implicit and explicit interfaces.
#
# So one can use the OO-style

x = np.linspace(0, 2, 100)  # Sample data.

# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, x, label='linear')  # Plot some data on the axes.
ax.plot(x, x**2, label='quadratic')  # Plot more data on the axes...
ax.plot(x, x**3, label='cubic')  # ... and some more.
ax.set_xlabel('x label')  # Add an x-label to the axes.
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("Simple Plot - Exemplo 2")  # Add a title to the axes.
ax.legend()  # Add a legend.

###############################################################################
# or the pyplot-style:



x = np.linspace(0, 2, 100)  # Sample data.

plt.figure(figsize=(5, 2.7), layout='constrained')
plt.plot(x, x, label='linear')  # Plot some data on the (implicit) axes.
plt.plot(x, x**2, label='quadratic')  # etc.
plt.plot(x, x**3, label='cubic')
plt.xlabel('x label')
plt.ylabel('y label')
plt.title("Simple Plot - Exemplo 3")
plt.legend()

###############################################################################
# (In addition, there is a third approach, for the case when embedding
# Matplotlib in a GUI application, which completely drops pyplot, even for
# figure creation. See the corresponding section in the gallery for more info:
# :ref:`user_interfaces`.)
#
# Matplotlib's documentation and examples use both the OO and the pyplot
# styles. In general, we suggest using the OO style, particularly for
# complicated plots, and functions and scripts that are intended to be reused
# as part of a larger project. However, the pyplot style can be very convenient
# for quick interactive work.
#
# .. note::
#
#    You may find older examples that use the ``pylab`` interface,
#    via ``from pylab import *``. This approach is strongly deprecated.
#
# Making a helper functions
# -------------------------
#
# If you need to make the same plots over and over again with different data
# sets, or want to easily wrap Matplotlib methods, use the recommended
# signature function below.


def my_plotter(ax, data1, data2, param_dict):
    """
    A helper function to make a graph.
    """
    out = ax.plot(data1, data2, **param_dict)
    return out

###############################################################################
# which you would then use twice to populate two subplots:

data1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))
my_plotter(ax1, data1, data2, {'marker': 'x'})
my_plotter(ax2, data3, data4, {'marker': 'o'})

###############################################################################
# Note that if you want to install these as a python package, or any other
# customizations you could use one of the many templates on the web;
# Matplotlib has one at `mpl-cookiecutter
# <https://github.com/matplotlib/matplotlib-extension-cookiecutter>`_
#
#
# Styling Artists
# ===============
#
# Most plotting methods have styling options for the Artists, accessible either
# when a plotting method is called, or from a "setter" on the Artist.  In the
# plot below we manually set the *color*, *linewidth*, and *linestyle* of the
# Artists created by `~.Axes.plot`, and we set the linestyle of the second line
# after the fact with `~.Line2D.set_linestyle`.

fig, ax = plt.subplots(figsize=(5, 2.7))
x = np.arange(len(data1))
ax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--')
ax.set_title("Exemplo 4")
l, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2)
l.set_linestyle(':')

###############################################################################
# Colors
# ------
#
# Matplotlib has a very flexible array of colors that are accepted for most
# Artists; see the :doc:`colors tutorial </tutorials/colors/colors>` for a
# list of specifications. Some Artists will take multiple colors.  i.e. for
# a `~.Axes.scatter` plot, the edge of the markers can be different colors
# from the interior:

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.scatter(data1, data2, s=50, facecolor='C0', edgecolor='k')
ax.set_title("Exemplo 5")

###############################################################################
# Linewidths, linestyles, and markersizes
# ---------------------------------------
#
# Line widths are typically in typographic points (1 pt = 1/72 inch) and
# available for Artists that have stroked lines.  Similarly, stroked lines
# can have a linestyle.  See the :doc:`linestyles example
# </gallery/lines_bars_and_markers/linestyles>`.
#
# Marker size depends on the method being used.  `~.Axes.plot` specifies
# markersize in points, and is generally the "diameter" or width of the
# marker.  `~.Axes.scatter` specifies markersize as approximately
# proportional to the visual area of the marker.  There is an array of
# markerstyles available as string codes (see :mod:`~.matplotlib.markers`), or
# users can define their own `~.MarkerStyle` (see
# :doc:`/gallery/lines_bars_and_markers/marker_reference`):

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.plot(data1, 'o', label='data1')
ax.plot(data2, 'd', label='data2')
ax.plot(data3, 'v', label='data3')
ax.plot(data4, 's', label='data4')
ax.set_title("Exemplo 6")
ax.legend()

###############################################################################
#
# Labelling plots
# ===============
#
# Axes labels and text
# --------------------
#
# `~.Axes.set_xlabel`, `~.Axes.set_ylabel`, and `~.Axes.set_title` are used to
# add text in the indicated locations (see :doc:`/tutorials/text/text_intro`
# for more discussion).  Text can also be directly added to plots using
# `~.Axes.text`:

mu, sigma = 115, 15
x = mu + sigma * np.random.randn(10000)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
# the histogram of the data
n, bins, patches = ax.hist(x, 50, density=True, facecolor='C0', alpha=0.75)

ax.set_xlabel('Length [cm]')
ax.set_ylabel('Probability')
ax.set_title('Aardvark lengths\n (not really)\n Exemplo 7')
ax.text(75, .025, r'$\mu=115,\ \sigma=15$')
ax.axis([55, 175, 0, 0.03])
ax.grid(True)

###############################################################################
# All of the `~.Axes.text` functions return a `matplotlib.text.Text`
# instance.  Just as with lines above, you can customize the properties by
# passing keyword arguments into the text functions::
#
#   t = ax.set_xlabel('my data', fontsize=14, color='red')
#
# These properties are covered in more detail in
# :doc:`/tutorials/text/text_props`.
#
# Using mathematical expressions in text
# --------------------------------------
#
# Matplotlib accepts TeX equation expressions in any text expression.
# For example to write the expression :math:`\sigma_i=15` in the title,
# you can write a TeX expression surrounded by dollar signs::
#
#     ax.set_title(r'$\sigma_i=15$')
#
# where the ``r`` preceding the title string signifies that the string is a
# *raw* string and not to treat backslashes as python escapes.
# Matplotlib has a built-in TeX expression parser and
# layout engine, and ships its own math fonts – for details see
# :doc:`/tutorials/text/mathtext`.  You can also use LaTeX directly to format
# your text and incorporate the output directly into your display figures or
# saved postscript – see :doc:`/tutorials/text/usetex`.
#
# Annotations
# -----------
#
# We can also annotate points on a plot, often by connecting an arrow pointing
# to *xy*, to a piece of text at *xytext*:

fig, ax = plt.subplots(figsize=(5, 2.7))

t = np.arange(0.0, 5.0, 0.01)
s = np.cos(2 * np.pi * t)
line, = ax.plot(t, s, lw=2)

ax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),
            arrowprops=dict(facecolor='black', shrink=0.05))

ax.set_title("Exemplo 8")
ax.set_ylim(-2, 2)

###############################################################################
# In this basic example, both *xy* and *xytext* are in data coordinates.
# There are a variety of other coordinate systems one can choose -- see
# :ref:`annotations-tutorial` and :ref:`plotting-guide-annotation` for
# details.  More examples also can be found in
# :doc:`/gallery/text_labels_and_annotations/annotation_demo`.
#
# Legends
# -------
#
# Often we want to identify lines or markers with a `.Axes.legend`:

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.plot(np.arange(len(data1)), data1, label='data1')
ax.plot(np.arange(len(data2)), data2, label='data2')
ax.plot(np.arange(len(data3)), data3, 'd', label='data3')
ax.set_title("Exemplo 9")
ax.legend()

##############################################################################
# Legends in Matplotlib are quite flexible in layout, placement, and what
# Artists they can represent. They are discussed in detail in
# :doc:`/tutorials/intermediate/legend_guide`.
#
# Axis scales and ticks
# =====================
#
# Each Axes has two (or three) `~.axis.Axis` objects representing the x- and
# y-axis. These control the *scale* of the Axis, the tick *locators* and the
# tick *formatters*. Additional Axes can be attached to display further Axis
# objects.
#
# Scales
# ------
#
# In addition to the linear scale, Matplotlib supplies non-linear scales,
# such as a log-scale.  Since log-scales are used so much there are also
# direct methods like `~.Axes.loglog`, `~.Axes.semilogx`, and
# `~.Axes.semilogy`.  There are a number of scales (see
# :doc:`/gallery/scales/scales` for other examples).  Here we set the scale
# manually:

fig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='constrained')
xdata = np.arange(len(data1))  # make an ordinal for this
data = 10**data1
axs[0].plot(xdata, data)
axs[0].set_title("Exemplo 10")
axs[1].set_yscale('log')
axs[1].plot(xdata, data)
axs[1].set_title("Exemplo 11")

##############################################################################
# The scale sets the mapping from data values to spacing along the Axis. This
# happens in both directions, and gets combined into a *transform*, which
# is the way that Matplotlib maps from data coordinates to Axes, Figure, or
# screen coordinates.  See :doc:`/tutorials/advanced/transforms_tutorial`.
#
# Tick locators and formatters
# ----------------------------
#
# Each Axis has a tick *locator* and *formatter* that choose where along the
# Axis objects to put tick marks.  A simple interface to this is
# `~.Axes.set_xticks`:

fig, axs = plt.subplots(2, 1, layout='constrained')
axs[0].plot(xdata, data1)
axs[0].set_title('Automatic ticks')
axs[0].set_title("Exemplo 12")

axs[1].plot(xdata, data1)
axs[1].set_xticks(np.arange(0, 100, 30), ['zero', '30', 'sixty', '90'])
axs[1].set_yticks([-1.5, 0, 1.5])  # note that we don't need to specify labels
axs[1].set_title('Manual ticks')
axs[1].set_title("Exemplo 13")

##############################################################################
# Different scales can have different locators and formatters; for instance
# the log-scale above uses `~.LogLocator` and `~.LogFormatter`. See
# :doc:`/gallery/ticks/tick-locators` and
# :doc:`/gallery/ticks/tick-formatters` for other formatters and
# locators and information for writing your own.
#
# Plotting dates and strings
# --------------------------
#
# Matplotlib can handle plotting arrays of dates and arrays of strings, as
# well as floating point numbers.  These get special locators and formatters
# as appropriate.  For dates:

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
dates = np.arange(np.datetime64('2021-11-15'), np.datetime64('2021-12-25'),
                  np.timedelta64(1, 'h'))
data = np.cumsum(np.random.randn(len(dates)))
ax.plot(dates, data)
cdf = mpl.dates.ConciseDateFormatter(ax.xaxis.get_major_locator())
ax.set_title("Exemplo 14")
ax.xaxis.set_major_formatter(cdf)

##############################################################################
# For more information see the date examples
# (e.g. :doc:`/gallery/text_labels_and_annotations/date`)
#
# For strings, we get categorical plotting (see:
# :doc:`/gallery/lines_bars_and_markers/categorical_variables`).

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
categories = ['turnips', 'rutabaga', 'cucumber', 'pumpkins']

ax.bar(categories, np.random.rand(len(categories)))
ax.set_title("Exemplo 15")

##############################################################################
# One caveat about categorical plotting is that some methods of parsing
# text files return a list of strings, even if the strings all represent
# numbers or dates.  If you pass 1000 strings, Matplotlib will think you
# meant 1000 categories and will add 1000 ticks to your plot!
#
#
# Additional Axis objects
# ------------------------
#
# Plotting data of different magnitude in one chart may require
# an additional y-axis. Such an Axis can be created by using
# `~.Axes.twinx` to add a new Axes with an invisible x-axis and a y-axis
# positioned at the right (analogously for `~.Axes.twiny`). See
# :doc:`/gallery/subplots_axes_and_figures/two_scales` for another example.
#
# Similarly, you can add a `~.Axes.secondary_xaxis` or
# `~.Axes.secondary_yaxis` having a different scale than the main Axis to
# represent the data in different scales or units. See
# :doc:`/gallery/subplots_axes_and_figures/secondary_axis` for further
# examples.

fig, (ax1, ax3) = plt.subplots(1, 2, figsize=(7, 2.7), layout='constrained')
l1, = ax1.plot(t, s)
ax2 = ax1.twinx()
l2, = ax2.plot(t, range(len(t)), 'C1')
ax2.legend([l1, l2], ['Sine (left)', 'Straight (right)'])
ax2.set_title("Exemplo 16")

ax3.plot(t, s)
ax3.set_xlabel('Angle [rad]')
ax4 = ax3.secondary_xaxis('top', functions=(np.rad2deg, np.deg2rad))
ax4.set_xlabel('Angle [°] \n Exemplo 17')

##############################################################################
# Color mapped data
# =================
#
# Often we want to have a third dimension in a plot represented by a colors in
# a colormap. Matplotlib has a number of plot types that do this:

X, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128))
Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)

fig, axs = plt.subplots(2, 2, layout='constrained')
pc = axs[0, 0].pcolormesh(X, Y, Z, vmin=-1, vmax=1, cmap='RdBu_r')
fig.colorbar(pc, ax=axs[0, 0])
axs[0, 0].set_title('pcolormesh()\n Exemplo 18')

co = axs[0, 1].contourf(X, Y, Z, levels=np.linspace(-1.25, 1.25, 11))
fig.colorbar(co, ax=axs[0, 1])
axs[0, 1].set_title('contourf()\n Exemplo 19')

pc = axs[1, 0].imshow(Z**2 * 100, cmap='plasma',
                          norm=mpl.colors.LogNorm(vmin=0.01, vmax=100))
fig.colorbar(pc, ax=axs[1, 0], extend='both')
axs[1, 0].set_title('imshow() with LogNorm()\n Exemplo 20')

pc = axs[1, 1].scatter(data1, data2, c=data3, cmap='RdBu_r')
fig.colorbar(pc, ax=axs[1, 1], extend='both')
axs[1, 1].set_title('scatter()\n Exemplo 21')

##############################################################################
# Colormaps
# ---------
#
# These are all examples of Artists that derive from  `~.ScalarMappable`
# objects.  They all can set a linear mapping between *vmin* and *vmax* into
# the colormap specified by *cmap*.  Matplotlib has many colormaps to choose
# from (:doc:`/tutorials/colors/colormaps`) you can make your
# own (:doc:`/tutorials/colors/colormap-manipulation`) or download as
# `third-party packages
# <https://matplotlib.org/mpl-third-party/#colormaps-and-styles>`_.
#
# Normalizations
# --------------
#
# Sometimes we want a non-linear mapping of the data to the colormap, as
# in the ``LogNorm`` example above.  We do this by supplying the
# ScalarMappable with the *norm* argument instead of *vmin* and *vmax*.
# More normalizations are shown at :doc:`/tutorials/colors/colormapnorms`.
#
# Colorbars
# ---------
#
# Adding a `~.Figure.colorbar` gives a key to relate the color back to the
# underlying data. Colorbars are figure-level Artists, and are attached to
# a ScalarMappable (where they get their information about the norm and
# colormap) and usually steal space from a parent Axes.  Placement of
# colorbars can be complex: see
# :doc:`/gallery/subplots_axes_and_figures/colorbar_placement` for
# details.  You can also change the appearance of colorbars with the
# *extend* keyword to add arrows to the ends, and *shrink* and *aspect* to
# control the size.  Finally, the colorbar will have default locators
# and formatters appropriate to the norm.  These can be changed as for
# other Axis objects.
#
#
# Working with multiple Figures and Axes
# ======================================
#
# You can open multiple Figures with multiple calls to
# ``fig = plt.figure()`` or ``fig2, ax = plt.subplots()``.  By keeping the
# object references you can add Artists to either Figure.
#
# Multiple Axes can be added a number of ways, but the most basic is
# ``plt.subplots()`` as used above.  One can achieve more complex layouts,
# with Axes objects spanning columns or rows, using `~.pyplot.subplot_mosaic`.

fig, axd = plt.subplot_mosaic([['upleft', 'right'],
                               ['lowleft', 'right']], layout='constrained')
axd['upleft'].set_title('upleft\n Exemplo 21')
axd['lowleft'].set_title('lowleft\n Exemplo 22')
axd['right'].set_title('right\n Exemplo 23')

###############################################################################
# Matplotlib has quite sophisticated tools for arranging Axes: See
# :doc:`/tutorials/intermediate/arranging_axes` and
# :doc:`/gallery/subplots_axes_and_figures/mosaic`.
#
#
# More reading
# ============
#
# For more plot types see :doc:`Plot types </plot_types/index>` and the
# :doc:`API reference </api/index>`, in particular the
# :doc:`Axes API </api/axes_api>`.

import numpy as np
print(np.arange(0.0, 5.0, 0.01)) # gera números de 0 até 5 (não incluso), variando 0.01)
print(np.linspace(0, 2, 100)) # gerar 100 números de 0 até 2

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-2, 2, 100)

#y = x**2

#z = x**(1/2)

#i = (x**(3/2))/(3/2)

y = 5 * x

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, y, label='x ^ 2')
#ax.plot(x, z, label='x ^ (1/2)')
#ax.plot(x, i, label='i')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("x ^ 2")  # Add a title to the axes.
ax.legend()

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-10, 10, 100)
s = np.sin(x)
c = (np.sin(2 * x))/2
z = s + c
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
#ax.plot(x, s, label='sen (x)')
#ax.plot(x, c, label=' (x)')
ax.plot(x, z, label='soma')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("sen (x)")  # Add a title to the axes.
ax.legend()

#y = x ^ 2
#y = - x ^ 2
#y = x ^ (1/2)
#y = 2 ^ x
#y = sen (x)
#y = sen (x + 2)
#y = sen (2 * x)
#y = cos (x)
#y = cos ((2 * x) - 3)


import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np


x = np.linspace(-5, 5, 100)


fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, x**2, label='x ^ 2')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("x ^ 2")  # Add a title to the axes.
ax.legend()


fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, -1 * (x**2), label='- x ^ 2')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("- x ^ 2")  # Add a title to the axes.
ax.legend()


fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, x**(1/2), label='x ^ (1/2)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("x ^ (1/2)")  # Add a title to the axes.
ax.legend()


fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, 2**x, label='2 ^ x')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("2 ^ x")  # Add a title to the axes.
ax.legend()


s = np.sin(x)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, s, label='sen (x)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("sen (x)")  # Add a title to the axes.
ax.legend()


s = np.sin(x + 2)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, s, label='sen (x + 2)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("sen (x + 2)")  # Add a title to the axes.
ax.legend()


s = np.sin(2 * x)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, s, label='sen (2 * x)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("sen (2 * x)")  # Add a title to the axes.
ax.legend()


s = np.cos(x)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, s, label='cos (x)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("cos (x)")  # Add a title to the axes.
ax.legend()


s = np.cos((2 * x) - 3)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, s, label='cos ((2 * x) - 3)')
ax.set_xlabel('x label')
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("cos ((2 * x) - 3)")  # Add a title to the axes.
ax.legend()

"""# **Aula do dia 27/05 - Funções**"""

# exemplo 1 - atenção definir função antes de chamar - melhor organização do código.

def imprime1():
    print('1'*40)

def imprimelinha():
    #imprime1()
    print('='*40)

imprimelinha()
print(f'{"CIÊNCIAS DE DADOS":^40}')
imprimelinha()

# exemplo 2
def imprimelinha():
    print('='*40)

def cabecalho(frase):
    imprimelinha()
    #print('='*40)
    print(f'{frase:^40}')
    imprimelinha()
    #print('='*40)

#cabecalho('ESTUDANDO FUNÇÕES')

frase = input(f'Digite cabeçalho: ')
cabecalho(frase)

# exemplo 3

def calcular_media(p1, p2):
    media = (p1 + p2) / 2
    print(f'Média calculada: {media:.2f} ')

calcular_media(10, 8)

# exemplo 4

def calcular_media(p1, p2):
    media = (p1 + p2) / 2
    print(f'P1 = {p1} e P2 = {p2}')
    print(f'Média calculada: {media:.2f} ')

#calcular_media(p1=10, p2=8)
#calcular_media(p2=10, p1=8)
#calcular_media(p1=9, p2=5)

p1 = float(input(f'Digite p1: '))
p2 = float(input(f'Digite p2: '))
calcular_media(p1, p2)

# exemplo 4 - sem função

p1=10
p2=8
media = (p1 + p2) / 2
print(f'P1 = {p1} e P2 = {p2}')
print(f'Média calculada: {media:.2f} ')

p2=10
p1=8
media = (p1 + p2) / 2
print(f'P1 = {p1} e P2 = {p2}')
print(f'Média calculada: {media:.2f} ')

p1=9
p2=5
media = (p1 + p2) / 2
print(f'P1 = {p1} e P2 = {p2}')
print(f'Média calculada: {media:.2f} ')

# exemplo 5

def contanumeros(*num):
    print(num, end=' ')
    tam = len(num)
    print(f'Total de números na tupla: {tam}')

contanumeros(1, 2, 3)
contanumeros(1, 2, 3, 4, 5)
contanumeros(1, 2)

# exemplo 6

def exibe_lista(lista):
    for i in range(0,len(lista)):
        print(f'Elemento {i} da lista {lista[i]}')

lista1 = (1, 2, 3, 4, 5)
exibe_lista(lista1)

lista2 = (5, 4, 3, 2, 1)
exibe_lista(lista2)

# lista[0] = 1
# lista[1] = 2 ...

# exemplo 6 - sem função

lista1 = (1, 2, 3, 4, 5)
for i in range(0,len(lista1)):
  print(f'Elemento {i} da lista {lista1[i]}')

lista2 = (5, 4, 3, 2, 1)
for i in range(0,len(lista2)):
  print(f'Elemento {i} da lista {lista2[i]}')

# função que receba n valores, digitados pelo usuário e exiba sua soma.

def somavalores(lista):
    soma = 0
    print(lista, end=' ')
    tam = len(lista)
    for i in range(0,tam):
        soma = soma + lista[i]
    print(f'Soma total dos números na lista: {soma}')

lista_num = []

while True:
  valor = float(input(f'Digite valor: '))
  lista_num.append(valor)
  resp = str(input('Quer continuar (s/n)?'))
  if resp in 'Nn':
    break

somavalores(lista_num)

# Receber n valores, calcular para cada valor a função y = 2x + 3, e então, plotar os pontos.
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

def plot_funcao(lista1, lista2):
    fig, ax = plt.subplots()
    ax.set_title("2x + 3")
    ax.plot(lista1, lista2)

lista_num = []
lista_result = []

while True:
  valor = float(input(f'Digite valor: '))
  result = (2 * valor) + 3
  lista_num.append(valor)
  lista_result.append(result)
  resp = str(input('Quer continuar (s/n)?'))
  if resp in 'Nn':
    break

print(lista_num)
print(lista_result)

plot_funcao(lista_num, lista_result)

# plotar função
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

def plot_funcao_x2(x):
    fig, ax = plt.subplots()
    ax.plot(x, x**2, label='x ^ 2')
    ax.plot(x, x**2 + 5, label='x ^ 2 + 5')
    ax.plot(x, x**2 + x, label='x ^ 2 + x')
    ax.plot(x, x**2 + x + 5, label='x ^ 2 + x + 5')
    ax.set_xlabel('x label')
    ax.set_ylabel('y label')  # Add a y-label to the axes.
    ax.set_title("x ^ 2")  # Add a title to the axes.
    ax.grid(True)
    ax.annotate('local min', xy=(-1/2, 4.75), xytext=(3, 1.5),
            arrowprops=dict(facecolor='black', shrink=0.005))
    ax.legend()

x = np.linspace(-3, 3, 100)

plot_funcao_x2(x)

#plot_funcao_x2_5(x)

import numpy as np
import matplotlib.pyplot as plt
def f(x): return x**3 + 1

x = np.linspace(-2,2)
plt.plot(x, f(x))
plt.grid()
plt.show()

data1 = [1, 2, 3, 4]
data2 = [2, 3, 4, 5]
data3 = [6, 7, 8, 9]
data4 = [-1, 0, 1]
fig, ax = plt.subplots(figsize=(5, 2.7))
ax.plot(data1, 'o', label='data1')
ax.plot(data2, 'd', label='data2')
ax.plot(data3, 'v', label='data3')
ax.plot(data4, 's', label='data4')
ax.set_title("Exemplo 6")
ax.legend()

from matplotlib_venn import venn2
from matplotlib import pyplot as plt

venn2(subsets = (5, 40, 10), set_labels = ('Group A', 'Group B'))
plt.show()

from matplotlib_venn import venn2_unweighted
from matplotlib import pyplot as plt

venn2_unweighted(subsets = (50, 10, 7),
                 set_labels = ('Group A',
                               'Group B'),
                 set_colors=("orange",
                             "blue"),alpha=0.7)

# https://acervolima.com/como-criar-e-personalizar-diagramas-de-venn-em-python/

from matplotlib_venn import venn3, venn3_circles
from matplotlib import pyplot as plt

# depict venn diagram
venn3(subsets=(20, 10, 12, 10, 9, 4, 3),
      set_labels=('Group A', 'Group B', 'Group C'),
      set_colors=("orange", "blue", "red"), alpha=0.7)

# outline of circle line style and width
venn3_circles(subsets=(20, 10, 12, 10, 9, 4, 3),
              linestyle="dashed", linewidth=2)

# title of the venn diagram
plt.title("Venn Diagram in geeks for geeks")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import cmath

def solve_and_plot_quadratic():
    print("Resolver uma equação de segundo grau no formato ax^2 + bx + c = 0")

    # Solicitar os coeficientes
    a = float(input("Digite o valor de a (coeficiente de x^2): "))
    b = float(input("Digite o valor de b (coeficiente de x): "))
    c = float(input("Digite o valor de c (termo constante): "))

    if a == 0:
        print("O valor de 'a' não pode ser 0 para uma equação de segundo grau.")
        return

    # Calcular o discriminante
    delta = b**2 - 4*a*c

    # Calcular as raízes
    if delta >= 0:
        root1 = (-b + cmath.sqrt(delta)) / (2*a)
        root2 = (-b - cmath.sqrt(delta)) / (2*a)
        print(f"As raízes reais da equação são: {root1.real:.2f} e {root2.real:.2f}")
    else:
        root1 = (-b + cmath.sqrt(delta)) / (2*a)
        root2 = (-b - cmath.sqrt(delta)) / (2*a)
        print(f"As raízes complexas da equação são: {root1} e {root2}")

    # Gerar valores para o gráfico
    x = np.linspace(-10, 10, 500)
    y = a*x**2 + b*x + c

    # Plotar a função
    plt.figure(figsize=(8, 6))
    plt.plot(x, y, label=f'{a}x² + {b}x + {c}', color='blue')
    plt.axhline(0, color='black', linewidth=0.8, linestyle='--')
    plt.axvline(0, color='black', linewidth=0.8, linestyle='--')

    # Marcar raízes no gráfico
    if delta >= 0:
        plt.scatter([root1.real, root2.real], [0, 0], color='red', label='Raízes')
    else:
        plt.text(0, 0, 'Raízes complexas\nnão são mostradas no gráfico', color='red')

    plt.title("Gráfico da função quadrática")
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.legend()
    plt.grid(True)
    plt.show()

# Chamar a função
solve_and_plot_quadratic()

import matplotlib.pyplot as plt
import numpy as np

# Propriedades do concreto e do aço
fck = 30e6  # Resistência característica à compressão do concreto (Pa)
fyk = 500e6  # Limite de escoamento do aço (Pa)
Ec = 30e9  # Módulo de elasticidade do concreto (Pa)
Es = 200e9  # Módulo de elasticidade do aço (Pa)
epsilon_cu = 0.0035  # Deformação máxima de compressão no concreto
epsilon_y = fyk / Es  # Deformação no escoamento do aço
epsilon_su = 0.01  # Deformação máxima do aço

# Funções de cálculo da tensão no concreto
def tensao_concreto(epsilon):
    if epsilon < 0:
        return 0
    elif epsilon <= epsilon_cu:
        return fck * (1 - (1 - epsilon / epsilon_cu) ** 2)
    else:
        return 0

# Funções de cálculo da tensão no aço
def tensao_aco(epsilon):
    if abs(epsilon) <= epsilon_y:
        return Es * epsilon
    elif abs(epsilon) <= epsilon_su:
        return np.sign(epsilon) * fyk
    else:
        return 0

# Intervalo de deformações
deformacoes_concreto = np.linspace(0, epsilon_cu * 1.2, 500)
deformacoes_aco = np.linspace(-epsilon_su * 1.2, epsilon_su * 1.2, 500)

# Cálculo das tensões
tensoes_concreto = [tensao_concreto(eps) for eps in deformacoes_concreto]
tensoes_aco = [tensao_aco(eps) for eps in deformacoes_aco]

# Gráficos dos diagramas tensão-deformação
plt.figure(figsize=(12, 6))

# Concreto
plt.subplot(1, 2, 1)
plt.plot(deformacoes_concreto, tensoes_concreto, label="Concreto", color="brown")
plt.axvline(x=epsilon_cu, color="red", linestyle="--", label="Deformação máxima")
plt.title("Diagrama Tensão-Deformação - Concreto")
plt.xlabel("Deformação (ε)")
plt.ylabel("Tensão (Pa)")
plt.grid()
plt.legend()

# Aço
plt.subplot(1, 2, 2)
plt.plot(deformacoes_aco, tensoes_aco, label="Aço", color="blue")
plt.axvline(x=epsilon_y, color="green", linestyle="--", label="Deformação no escoamento")
plt.axvline(x=-epsilon_y, color="green", linestyle="--")
plt.axvline(x=epsilon_su, color="red", linestyle="--", label="Deformação máxima")
plt.axvline(x=-epsilon_su, color="red", linestyle="--")
plt.title("Diagrama Tensão-Deformação - Aço")
plt.xlabel("Deformação (ε)")
plt.ylabel("Tensão (Pa)")
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()

"""Aqui está uma explicação detalhada do código, abordando as funções e a lógica implementada para modelar os domínios de deformação de concreto armado:

---

### **1. Importação de Bibliotecas**
```python
import matplotlib.pyplot as plt
import numpy as np
```
- **`matplotlib.pyplot`**: Usada para criar gráficos dos diagramas tensão-deformação.
- **`numpy`**: Utilizada para gerar valores de deformação em intervalos contínuos e realizar cálculos matemáticos.

---

### **2. Definição de Propriedades dos Materiais**
```python
fck = 30e6  # Resistência característica à compressão do concreto (Pa)
fyk = 500e6  # Limite de escoamento do aço (Pa)
Ec = 30e9  # Módulo de elasticidade do concreto (Pa)
Es = 200e9  # Módulo de elasticidade do aço (Pa)
epsilon_cu = 0.0035  # Deformação máxima de compressão no concreto
epsilon_y = fyk / Es  # Deformação no escoamento do aço
epsilon_su = 0.01  # Deformação máxima do aço
```
- **Concreto (`fck`, `Ec`, `epsilon_cu`)**:
  - `fck`: Resistência característica à compressão, usada para definir o limite de tensão no concreto.
  - `Ec`: Módulo de elasticidade, representando a rigidez inicial.
  - `epsilon_cu`: Deformação máxima antes do esmagamento.
- **Aço (`fyk`, `Es`, `epsilon_y`, `epsilon_su`)**:
  - `fyk`: Tensão no limite de escoamento.
  - `Es`: Módulo de elasticidade, define o comportamento linear inicial.
  - `epsilon_y`: Deformação no início do escoamento, calculada como `fyk / Es`.
  - `epsilon_su`: Deformação máxima considerada antes da ruptura.

---

### **3. Função para Tensão no Concreto**
```python
def tensao_concreto(epsilon):
    if epsilon < 0:
        return 0
    elif epsilon <= epsilon_cu:
        return fck * (1 - (1 - epsilon / epsilon_cu) ** 2)
    else:
        return 0
```
- Modela o comportamento parabólico-retangular do concreto:
  - Se `epsilon < 0`: A tensão é zero (o concreto não resiste à tração considerável).
  - Se `0 ≤ epsilon ≤ epsilon_cu`: Aplica a equação parabólica para tensão crescente.
  - Se `epsilon > epsilon_cu`: A tensão é zero (o concreto atinge a ruptura por esmagamento).

---

### **4. Função para Tensão no Aço**
```python
def tensao_aco(epsilon):
    if abs(epsilon) <= epsilon_y:
        return Es * epsilon
    elif abs(epsilon) <= epsilon_su:
        return np.sign(epsilon) * fyk
    else:
        return 0
```
- Modela o comportamento elástico-perfeito plástico do aço:
  - **Região elástica** (`|epsilon| ≤ epsilon_y`): A tensão é proporcional à deformação.
  - **Região plástica** (`epsilon_y < |epsilon| ≤ epsilon_su`): A tensão permanece constante em `fyk`.
  - **Ruptura** (`|epsilon| > epsilon_su`): A tensão é zero.

---

### **5. Definição do Intervalo de Deformações**
```python
deformacoes_concreto = np.linspace(0, epsilon_cu * 1.2, 500)
deformacoes_aco = np.linspace(-epsilon_su * 1.2, epsilon_su * 1.2, 500)
```
- Cria vetores de valores de deformação:
  - **Concreto**: Deformação varia de 0 até 120% de `epsilon_cu`.
  - **Aço**: Deformação varia de -120% até +120% de `epsilon_su`.

---

### **6. Cálculo das Tensões**
```python
tensoes_concreto = [tensao_concreto(eps) for eps in deformacoes_concreto]
tensoes_aco = [tensao_aco(eps) for eps in deformacoes_aco]
```
- Utiliza as funções `tensao_concreto` e `tensao_aco` para calcular a tensão correspondente a cada valor de deformação.

---

### **7. Geração dos Gráficos**
#### **Concreto**
```python
plt.subplot(1, 2, 1)
plt.plot(deformacoes_concreto, tensoes_concreto, label="Concreto", color="brown")
plt.axvline(x=epsilon_cu, color="red", linestyle="--", label="Deformação máxima")
plt.title("Diagrama Tensão-Deformação - Concreto")
plt.xlabel("Deformação (ε)")
plt.ylabel("Tensão (Pa)")
plt.grid()
plt.legend()
```
- Cria um gráfico para o concreto:
  - Plota a curva tensão-deformação.
  - Adiciona uma linha vertical indicando a deformação máxima (`epsilon_cu`).

#### **Aço**
```python
plt.subplot(1, 2, 2)
plt.plot(deformacoes_aco, tensoes_aco, label="Aço", color="blue")
plt.axvline(x=epsilon_y, color="green", linestyle="--", label="Deformação no escoamento")
plt.axvline(x=-epsilon_y, color="green", linestyle="--")
plt.axvline(x=epsilon_su, color="red", linestyle="--", label="Deformação máxima")
plt.axvline(x=-epsilon_su, color="red", linestyle="--")
plt.title("Diagrama Tensão-Deformação - Aço")
plt.xlabel("Deformação (ε)")
plt.ylabel("Tensão (Pa)")
plt.grid()
plt.legend()
```
- Cria um gráfico para o aço:
  - Plota a curva tensão-deformação.
  - Adiciona linhas verticais para as deformações características (`epsilon_y`, `epsilon_su`).

---

### **8. Ajuste e Exibição dos Gráficos**
```python
plt.tight_layout()
plt.show()
```
- **`plt.tight_layout()`**: Garante que os gráficos fiquem organizados e não se sobreponham.
- **`plt.show()`**: Exibe os gráficos.

---

### **Resumo do Resultado**
- **Gráfico do Concreto**:
  - Mostra o comportamento parabólico-retangular até o esmagamento.
- **Gráfico do Aço**:
  - Destaca o comportamento elástico até o escoamento e a tensão constante na região plástica.

Este código é uma simplificação prática para entender os domínios de deformação em estruturas de concreto armado. Em aplicações reais, os valores de entrada e as funções podem ser ajustados para atender a projetos específicos e normas locais.
"""